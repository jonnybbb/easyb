<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"file:////@docbook.base@/dtd/docbookx.dtd">
<book>
  <bookinfo>
    <title>@docbook.project.name@ User Guide</title>

    <pubdate>@build.date@</pubdate>

    <copyright>
      <year>Copyright @build.year@ easyb.org</year>
    </copyright>

    <releaseinfo>@docbook.project.version@</releaseinfo>

    <author>
      <surname>easyb Development Team</surname>

      <email><ulink
      url="mailto:easyb-users@googlegroups.com">easyb-users@googlegroups.com
      </ulink></email>
    </author>
  </bookinfo>

  <chapter>
    <title>Overview</title>

    <para>easyb is a behavior driven development framework for the Java
    platform. By using a Domain Specific Language, easyb aims to enable
    executable, yet readable documentation.</para>

    <section>
      <title>History</title>

      <para>Behavior driven development (or BDD) isn't anything new or
      revolutionary-- it's just an evolutionary offshoot of test driven
      development, in which the word test is replaced by the word should.
      Semantics aside, a lot of people have found that the concept of should
      is a much more natural development driver than the concept of testing.
      In fact, when you think in terms of behavior (i.e. shoulds) you'll find
      that writing specifications is easier to do first, which is the intent
      of test driven development in the first place.</para>

      <para>What came next was a natural progression from idea to
      implementation. The idea of TDD had become widely accepted, primarily
      because of its freely available tooling in the form of JUnit. BDD is
      following the same path and pulling it to the forefront are a new crop
      of tools to support it. One of the first was JBehave by Dan North. Dan
      is regarded as one of the fathers of BDD thru his role in defining it
      and evangelizing those concepts. JBehave implemented many of the ideas
      and terms of BDD and did so in code which is the real reference for most
      developers. </para>

      <para>There was still a significant problem. BDD by its nature is a very
      Stakeholder centric process and trying to marry up Non-Technical folks
      with Java syntax is just a recipe for failure or frustration at best.
      Around the same time, ruby had taken off thanks to Rails and as such
      DomainSpecificLanguages were becoming a hotbed of discussion among
      developers. It was only a matter of time before all of the above met at
      the crossroads. RSpec was first on the scene and provided an early form
      of BDD that used 'it should' as its primary means of describing
      behavior. It was a fantastic spark to the community and most assuredly a
      step in the right direction but it too had its drawbacks. RSpec ran on
      the Ruby VM and this left the Java world out in the cold. Running RSpec
      via JRuby was possible but JRuby was a fledgeling project and also came
      with its own baggage, not the least of which was that Enterprise
      organizations weren't ready to embrace Ruby or even JRuby.</para>

      <para>Enter groovy and easyb. Groovy runs natively on the JVM with
      nothing more than a jar file in the classpath. This is key to lowering
      the barriers of adoption by that Enterprise segment of the population.
      What Groovy also provides is a dynamic language with all the power and
      syntatic sugar opportunities for creating a rich DSL. With all the
      pieces now available, easyb was primed to step in and put them all in
      place.</para>
    </section>

    <section>
      <title>Goals</title>

      <itemizedlist>
        <listitem>
          <para>Easy</para>
        </listitem>

        <listitem>
          <para>Natual Language DSL for capturing Behaviors</para>
        </listitem>

        <listitem>
          <para>Bridge gap between Stakeholders and Development</para>
        </listitem>
      </itemizedlist>

      <para>Easyb accomplishes all of these goals in spades as you'll see
      throughout this document. Goal #1 has always been, and continues to be,
      that it must be easy. To do so, easyb provides out of the box a slew of
      great features and the easyb team has bundled along with (and built on
      top of them) a suite of products and plugins.</para>
    </section>
  </chapter>

  <chapter>
    <title>Usage</title>

    <para>Some stuff about running easyb</para>
  </chapter>

  <chapter>
    <title>Syntax</title>

    <indexterm class="startofrange" id="ix.syntax">
      <primary>Syntax Specification</primary>
    </indexterm>

    <para>easyb contains a rich language for capturing behaviors as executable
    documentation.</para>

    <section>
      <title>Stories</title>

      <indexterm class="startofrange" id="ix.syntax.stories">
        <primary>Syntax Specification</primary>

        <secondary>Stories</secondary>
      </indexterm>

      <para>These entries are normally found within a Story file.</para>

      <variablelist>
        <formalpara>
          <title>scenario</title>

          <indexterm>
            <primary>scenario</primary>
          </indexterm>

          <para>Illustrate a specific aspepct of behavior of the
          application<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside story file. Multiple may be included in a
                  single story file.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>scenario "description here", {
  ...
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>given, andGiven</title>

          <indexterm>
            <primary>given</primary>
          </indexterm>

          <indexterm>
            <primary>andGiven</primary>

            <see>given</see>
          </indexterm>

          <para>Context specific to this scenario. Object and Data setup will
          often happen in a given.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside scenario. Multiple may appear in each scenario.
                  Also appears directly in a story file outside of a scenario
                  (not recommended).</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>scenario "scenario description here", {
  given "given description here", {
    // given impl here
  }
 
  andGiven "andGiven description here", {
    // andGiven impl here
  }

  ...
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>when</title>

          <indexterm>
            <primary>when</primary>
          </indexterm>

          <para>An action to be taken.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside scenario. Follows any givens. Multiple may
                  appear in each scenario. Also appears directly in a story
                  file outside of a scenario (not recommended).</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>scenario "scenario description here", {
  ...

  when "when description here", {
    // when impl here
  }

  ...
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>then, andThen</title>

          <indexterm>
            <primary>then</primary>
          </indexterm>

          <indexterm>
            <primary>andThen</primary>

            <see>then</see>
          </indexterm>

          <para>Validation of expected outcome.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside scenario. Follows any whens. Multiple may
                  appear in each scenario. Also appears directly in a story
                  file outside of a scenario (not recommended).</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>scenario "scenario description here", {
  ...

  then "then description here", {
    // then impl here
  }

  andThen "andThen description here", {
    // andThen impl here
  }

  ...
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>narrative</title>

          <indexterm>
            <primary>narrative</primary>
          </indexterm>

          <para>Gives a bried description of what is to be delivered. Provides
          a container for other narrative components.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside a story, preferably at the top. Only one can
                  appear in each story.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>narrative "narrative description here", {
  ...
}

scenario "scenario description here"  ...</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>as_a</title>

          <indexterm>
            <primary>as_a</primary>
          </indexterm>

          <para>An aspect that describes the person, or thing, that will
          benefit from the feature.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside narrative, prior to i_want.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>narrative "narrative description here", {
  as_a "role description here"
  ...
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>i_want</title>

          <indexterm>
            <primary>i_want</primary>
          </indexterm>

          <para>Describes something that the system should do or a feature in
          business terms and not in terms of technology<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside narrative, following as_a.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>narrative "narrative description here", {
  ...
  i_want "feature description here"
  ...
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>so_that</title>

          <indexterm>
            <primary>so_that</primary>
          </indexterm>

          <para>Describes the business value accrued from this
          feature.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>Inside narrative, following i_want.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>narrative "narrative description here", {
  ...
  so_that "benefit description here"
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </variablelist>

      <indexterm class="endofrange" startref="ix.syntax.stories" />
    </section>

    <section>
      <title>Specifications</title>

      <indexterm class="startofrange" id="ix.syntax.specifications">
        <primary>Syntax Specification</primary>

        <secondary>Specifications</secondary>
      </indexterm>

      <para>The entries below would normally be found exclusively in a
      Specification file.</para>

      <variablelist>
        <formalpara>
          <title>it</title>

          <indexterm>
            <primary>it</primary>
          </indexterm>

          <para>Captures a specification. Usually described in terms of
          should.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>At the root of a Specification file.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>it "should have an it description here", {
  // it impl here
}</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </variablelist>

      <indexterm class="endofrange" startref="ix.syntax.specifications" />
    </section>

    <section>
      <title>Common</title>

      <indexterm class="startofrange" id="ix.syntax.common">
        <primary>Syntax Specification</primary>

        <secondary>Common</secondary>
      </indexterm>

      <para>The following can be placed in both Story and Specification
      files.</para>

      <variablelist>
        <formalpara>
          <title>and (syntax replacement)</title>

          <indexterm>
            <primary>and (syntax replacement)</primary>
          </indexterm>

          <para>Used as replacement syntax for story and specification
          contstructs. Carries the connotation that it is equivalent to
          whatever the previous story or specification construct
          was.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>between, or in place of, story and specification
                  constructs (given, then, etc)</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>...
given "a given description here", {
  // given impl here
}

and "equivalent to another given", {
  // another given impl here
}
...</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>and (assertion chain)</title>

          <indexterm>
            <primary>and (assertion chain)</primary>
          </indexterm>

          <para>Used to logically tie together assertion statements.
          <itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>within a story or specification construct, placed
                  between assertions to give more natural language
                  readability</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>true.shouldBe true
and
false.shouldBe false</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>before</title>

          <indexterm>
            <primary>before</primary>
          </indexterm>

          <para>Actions to be taken before any Story or Scenario components
          are run. Usually used for boilerplate setup common to all scenarios
          or specifications in that file. Placement should be prior to any
          scenarios (in a story) or specifications.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>At the top of a story or specification, prior to any
                  other easyb components.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>...
before "a before description here", {
  // before impl here
}
...</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>before_each</title>

          <indexterm>
            <primary>before_each</primary>
          </indexterm>

          <para>Actions to be taken before every Story or Scenario component
          is run. Usually used for boilerplate setup common to all scenarios
          or specifications in that file. Placement should be prior to any
          scenarios (in a story) or specifications.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>At the top of a story or specification, prior to any
                  other easyb components.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>...
before_each "a before_each description here", {
  // before_each impl here
}
...</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>after</title>

          <indexterm>
            <primary>after</primary>
          </indexterm>

          <para>Actions to be taken after any Story or Scenario components are
          run. Usually used for boilerplate setup common to all scenarios or
          specifications in that file. Placement should be prior to any
          scenarios (in a story) or specifications.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>At the top of a story or specification. Follows any
                  before or before_each, prior to any other easyb
                  components.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>...
after "an after description here", {
  // after impl here
}
...</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>after_each</title>

          <indexterm>
            <primary>after_each</primary>
          </indexterm>

          <para>Actions to be taken after every Story or Scenario component is
          run. Placement should be prior to any scenarios (in a story) or
          specifications.<itemizedlist>
              <listitem>
                <formalpara>
                  <title>Appears</title>

                  <para>At the top of a story or specification. Follows any
                  before or before_each, prior to any other easyb
                  components.</para>
                </formalpara>
              </listitem>

              <listitem>
                <programlisting>...
after_each "an after_each description here", {
  // after_each impl here
}
...</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </variablelist>

      <indexterm class="endofrange" startref="ix.syntax.common" />
    </section>

    <section>
      <title>Assertions</title>

      <para>The meat of the syntactic sugar easyb provides for making
      assertions very readable.</para>

      <indexterm />

      <section>
        <title>should</title>

        <para>All of the should assertions work from left to right. The object
        on the left having the attributes that will be validated by what is on
        the right.</para>

        <indexterm class="startofrange" id="ix.syntax.assertions.should">
          <primary>Syntax Specification</primary>

          <secondary>Should Assertions</secondary>
        </indexterm>

        <formalpara>
          <title>Appears</title>

          <para>Inside any of the story or scenario components, typically as
          part of an 'it' or a 'then'.</para>
        </formalpara>

        <variablelist>
          <formalpara>
            <title>shouldBe</title>

            <indexterm>
              <primary>shouldBe</primary>
            </indexterm>

            <para>Equality of target checked against value passed
            in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldBe true
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldEqual</title>

            <indexterm>
              <primary>shouldEqual</primary>

              <seealso>shouldBe</seealso>
            </indexterm>

            <para>Synonym for shouldBe. Equality of target checked against
            value passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldEqual true
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldBeEqual</title>

            <indexterm>
              <primary>shouldBeEqual</primary>

              <seealso>shouldBe</seealso>
            </indexterm>

            <para>Synonym for shouldBe. Equality of target checked against
            value passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldBeEqual true
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldBeEqualTo</title>

            <indexterm>
              <primary>shouldBeEqualTo</primary>

              <seealso>shouldBe</seealso>
            </indexterm>

            <para>Synonym for shouldBe. Equality of target checked against
            value passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldBeEqualTo true
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldNotBe</title>

            <indexterm>
              <primary>shouldNotBe</primary>
            </indexterm>

            <para>Inequality of target checked against value passed
            in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldNotBe false
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldNotEqual</title>

            <indexterm>
              <primary>shouldNotEqual</primary>

              <seealso>shouldNotBe</seealso>
            </indexterm>

            <para>Synonym for shouldNotBe. Inequality of target checked
            against value passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldNotEqual false
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldNotBeEqual</title>

            <indexterm>
              <primary>shouldNotBeEqual</primary>

              <seealso>shouldNotBe</seealso>
            </indexterm>

            <para>Synonym for shouldNotBe. Inequality of target checked
            against value passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldNotBeEqual false
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldNotBeEqualTo</title>

            <indexterm>
              <primary>shouldNotBeEqualTo</primary>

              <seealso>shouldNotBe</seealso>
            </indexterm>

            <para>Synonym for shouldNotBe. Inequality of target object checked
            against value passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
true.shouldNotBeEqualTo false
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldBeA</title>

            <indexterm>
              <primary>shouldBeA</primary>
            </indexterm>

            <para>Verifies the target's type matches that which is passed
            in.<itemizedlist>
                <listitem>
                  <programlisting>...
"StringValue".shouldBeA(String)
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldBeA</title>

            <indexterm>
              <primary>shouldBeA</primary>
            </indexterm>

            <para>Verifies the target's type matches that which is passed
            in.<itemizedlist>
                <listitem>
                  <programlisting>...
"StringValue".shouldBeA String
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldBeAn</title>

            <indexterm>
              <primary>shouldBeAn</primary>

              <seealso>shouldBeA</seealso>
            </indexterm>

            <para>Synonym for shouldBeA. Verifies the target's type matches
            that which is passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
1.shouldBeAn Integer
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldNotBeA</title>

            <indexterm>
              <primary>shouldNotBeA</primary>
            </indexterm>

            <para>Verifies the target's type does not match that which is
            passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
1.shouldNotBeA String
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldNotBeAn</title>

            <indexterm>
              <primary>shouldNotBeAn</primary>

              <seealso>shouldNotBeA</seealso>
            </indexterm>

            <para>Synonym for shouldNotBeA. Verifies the target's type does
            not match that which is passed in.<itemizedlist>
                <listitem>
                  <programlisting>...
1.shouldBeAn Integer
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldBeGreaterThan</title>

            <indexterm>
              <primary>shouldBeGreaterThan</primary>
            </indexterm>

            <para>Verifies the target is greater than the value passed in
            using groovy comparison.<itemizedlist>
                <listitem>
                  <programlisting>...
2.shouldBeGreaterThan 1
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldBeLessThan</title>

            <indexterm>
              <primary>shouldBeLessThan</primary>
            </indexterm>

            <para>Verifies the target is less than the value passed in using
            groovy comparison.<itemizedlist>
                <listitem>
                  <programlisting>...
1.shouldBeLessThan 2
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldHave</title>

            <indexterm>
              <primary>shouldHave</primary>
            </indexterm>

            <para>Verifies the target contains the value passed in.
            Collections and Strings are handled in the value positions.
            Collections, Strings and Object Fields are handled in the target
            position.<itemizedlist>
                <listitem>
                  <programlisting>...
"test".shouldHave("est")

myMap = [value: "Andy", another: 34, 55: "test"]
myMap.shouldHave("Andy")
myMap.shouldHave(55: "test")
myMap.shouldHave([value: "Andy", 55: "test"])
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>shouldNotHave</title>

            <indexterm>
              <primary>shouldNotHave</primary>
            </indexterm>

            <para>Verifies the target contains the value passed in.
            Collections and Strings are handled in the value positions.
            Collections, Strings and Object Fields are handled in the target
            position.<itemizedlist>
                <listitem>
                  <programlisting>...
myMap = [value: "Andy", another: 34, 55: "test"]
myMap.shouldNotHave("Mervin") // covers a value in a map
myMap.shouldNotHave([value: "Mervin", 55: "somethingnottest"]) // covers a map in a map where neither value is found
myMap.shouldNotHave([value: "Andy", 55: "somethingnottest"])  // covers a map in a map where at least one value is not found
myMap.shouldNotHave(55: "foobar") // covers map where key exists but value doesn't
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </variablelist>

        <indexterm class="endofrange" startref="ix.syntax.assertions.should" />
      </section>

      <section>
        <title>ensure</title>

        <para>All of the ensure assertions validate the target (specified as
        the argument to ensure()) matches the assertion in the term or the
        argument to the right of the term.</para>

        <indexterm class="startofrange" id="ix.syntax.ensure">
          <primary>Syntax Specification</primary>

          <secondary>ensure</secondary>
        </indexterm>

        <formalpara>
          <title>Appears</title>

          <para>Ensure normally appears inside an 'it' or 'then. All of the
          assertion terms listed below will appear inside the block associated
          with the ensure itself.</para>
        </formalpara>

        <variablelist>
          <formalpara>
            <title>isNull</title>

            <indexterm>
              <primary>isNull</primary>
            </indexterm>

            <para>Value of target must be null.<itemizedlist>
                <listitem>
                  <programlisting>ensure(someNullTargetValue) {
 isNull
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isNotNull</title>

            <indexterm>
              <primary>isNotNull</primary>
            </indexterm>

            <para>Value of target must not be null.<itemizedlist>
                <listitem>
                  <programlisting>ensure(someNonNullTargetValue) {
 isNotNull
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isA&lt;class type&gt;</title>

            <indexterm>
              <primary>isA</primary>
            </indexterm>

            <para>Value of target must be the same class as the &lt;class
            type&gt; at the end of the term.<itemizedlist>
                <listitem>
                  <programlisting>ensure(aStringTarget) {
 isAString
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isEqualTo(value)</title>

            <indexterm>
              <primary>isEqualTo(value)</primary>
            </indexterm>

            <para>Value of target must equal the value of the argument to
            isEqualTo.<itemizedlist>
                <listitem>
                  <programlisting>ensure(true) {
 isEqualTo(true)
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isEqualTo&lt;value&gt;</title>

            <indexterm>
              <primary>isEqualTo&lt;value&gt;</primary>
            </indexterm>

            <para>Value of target must equal the value at the end of the
            term.<itemizedlist>
                <listitem>
                  <programlisting>ensure("Test") {
 isEqualToTest
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isNotEqualTo(value)</title>

            <indexterm>
              <primary>isNotEqualTo(value)</primary>
            </indexterm>

            <para>Value of target must not equal the value of the argument to
            isNotEqualTo.<itemizedlist>
                <listitem>
                  <programlisting>ensure(false) {
 isNotEqualTo(true)
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isNotEqualTo&lt;value&gt;</title>

            <indexterm>
              <primary>isNotEqualTo&lt;value&gt;</primary>
            </indexterm>

            <para>Value of target must not equal the value at the end of the
            term.<itemizedlist>
                <listitem>
                  <programlisting>ensure("Foo") {
 isNotEqualToBar
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isTrue</title>

            <indexterm>
              <primary>isTrue</primary>
            </indexterm>

            <para>Value of target must be true.<itemizedlist>
                <listitem>
                  <programlisting>ensure(true) {
 isTrue
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>isFalse</title>

            <indexterm>
              <primary>isFalse</primary>
            </indexterm>

            <para>Value of target must be false.<itemizedlist>
                <listitem>
                  <programlisting>ensure(false) {
 isFalse
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>ensureThrows</title>

            <indexterm>
              <primary>ensureThrows</primary>
            </indexterm>

            <para>This is a special variant of the ensure clause. It is used
            to verify that a block of code must throw an exception of the type
            specified.<itemizedlist>
                <listitem>
                  <programlisting>ensureThrows(RuntimeException.class) {
  String tst = null
  tst.toUpperCase()
}</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </variablelist>

        <indexterm class="endofrange" startref="ix.syntax.ensure" />
      </section>

      <section>
        <title>common</title>

        <para>The remaining assertions are common to both stories and
        specifications. They can also be used standalone (inside of an ensure)
        as well as a magic method (similar to the should syntax).</para>

        <indexterm class="startofrange" id="ix.syntax.assertions.common">
          <primary>Syntax Specification</primary>

          <secondary>common assertions</secondary>
        </indexterm>

        <variablelist>
          <formalpara>
            <title>has</title>

            <indexterm>
              <primary>has</primary>
            </indexterm>

            <para>Target's contents must consist of (at minimum) the contents
            of the argument to has.<itemizedlist>
                <listitem>
                  <programlisting>ensure("Test") {
 has("es")
}</programlisting>

                  <programlisting>...
 "Test".has("es") // Preferable to use shouldHave instead for readability
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>contains</title>

            <indexterm>
              <primary>contains</primary>
            </indexterm>

            <para>Target's contents must consist of (at minimum) the contents
            of the argument to contains.<itemizedlist>
                <listitem>
                  <programlisting>ensure("Test") {
 contains("es")
}</programlisting>

                  <programlisting>...
 "Test".contains("es") // Preferable to use shouldHave instead for readability
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>startsWith</title>

            <indexterm>
              <primary>startsWith</primary>
            </indexterm>

            <para>Target's contents must begin with the contents of the
            argument to startsWith.<itemizedlist>
                <listitem>
                  <programlisting>ensure("Test") {
  startsWith("Te")
}</programlisting>

                  <programlisting>... // Issue 110. shouldStartWith doesn't exist in the dsl yet
 "Test".shouldStartWith("Te") // Preferable to use shouldHave instead for readability
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>endsWith</title>

            <indexterm>
              <primary>endsWith</primary>
            </indexterm>

            <para>Target's contents must end with the contents of the argument
            to endsWith.<itemizedlist>
                <listitem>
                  <programlisting>ensure("Test") {
  endsWith("st")
}</programlisting>

                  <programlisting>... // Issue 111. shouldEndWith doesn't exist in the dsl yet
 "Test".shouldEndWith("st") // Preferable to use shouldHave instead for readability
...</programlisting>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </variablelist>

        <indexterm class="endofrange" startref="ix.syntax.assertions.common" />
      </section>
    </section>

    <indexterm class="endofrange" startref="ix.syntax" />
  </chapter>

  <chapter>
    <title>Appendix</title>

    <section>
      <title>Glossary<anchor id="glossary" /></title>

      <glosslist>
        <glossentry>
          <glossterm>BDD</glossterm>

          <glossdef>
            <para>See Behavior Driven Development</para>
          </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>Behavior Driven Development</glossterm>

          <glossdef>
            <para>Agile software development technique that encourages
            collaboration between developers, QA and non-technical or business
            participants in a software project. It was originally conceived in
            2003 by Dan North [1] as a response to Test Driven Development,
            and has evolved over the last few years. The focus of BDD is the
            language and interactions used in the process of software
            development. Behavior-driven developers use their native language
            in combination with the ubiquitous language of Domain Driven
            Design to describe the purpose and benefit of their code. This
            allows the developers to focus on why the code should be created,
            rather than the technical details, and minimizes translation
            between the technical language in which the code is written and
            the domain language spoken by the business, users, stakeholders,
            project management etc. (Courtesy:
            http://en.wikipedia.org/wiki/Behavior_driven_development)</para>
          </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>Story</glossterm>

          <glossdef>
            <para>Description of a requirement, which has an associated
            benefit and criteria for validation. Contains any of the following
            components: scenario, given, when then. It also may contain a
            narrative with the following components: narrative, as_a, i_want,
            so_that.</para>
          </glossdef>
        </glossentry>
      </glosslist>

      <para></para>
    </section>
  </chapter>

  <index></index>
</book>
