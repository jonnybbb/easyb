<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"file:////@docbook.base@/dtd/docbookx.dtd">
<book>
  <bookinfo>
    <title>@docbook.project.name@ User Guide</title>

    <pubdate>@build.date@</pubdate>

    <copyright>
      <year>Copyright @build.year@ easyb.org</year>
    </copyright>

    <releaseinfo>@docbook.project.version@</releaseinfo>

    <author>
      <surname>easyb Development Team</surname>

      <email><ulink
      url="mailto:easyb-users@googlegroups.com">easyb-users@googlegroups.com
      </ulink></email>
    </author>
  </bookinfo>

  <chapter>
    <title>Overview</title>

    <para>easyb is a behavior driven development framework for the Java
    platform. By using a Domain Specific Language, easyb aims to enable
    executable, yet readable documentation.</para>

    <section>
      <title>History</title>

      <para>Behavior driven development (or BDD) isn't anything new or
      revolutionary-- it's just an evolutionary offshoot of test driven
      development, in which the word test is replaced by the word should.
      Semantics aside, a lot of people have found that the concept of should
      is a much more natural development driver than the concept of testing.
      In fact, when you think in terms of behavior (i.e. shoulds) you'll find
      that writing specifications is easier to do first, which is the intent
      of test driven development in the first place.</para>

      <para>What came next was a natural progression from idea to
      implementation. The idea of TDD had become widely accepted, primarily
      because of its freely available tooling in the form of JUnit. BDD is
      following the same path and pulling it to the forefront are a new crop
      of tools to support it. One of the first was JBehave by Dan North. Dan
      is regarded as one of the fathers of BDD thru his role in defining it
      and evangelizing those concepts. JBehave implemented many of the ideas
      and terms of BDD and did so in code which is the real reference for most
      developers.</para>

      <para>There was still a significant problem. BDD by its nature is a very
      Stakeholder centric process and trying to marry up Non-Technical folks
      with Java syntax is just a recipe for failure or frustration at best.
      Around the same time, ruby had taken off thanks to Rails and as such
      DomainSpecificLanguages were becoming a hotbed of discussion among
      developers. It was only a matter of time before all of the above met at
      the crossroads. RSpec was first on the scene and provided an early form
      of BDD that used 'it should' as its primary means of describing
      behavior. It was a fantastic spark to the community and most assuredly a
      step in the right direction but it too had its drawbacks. RSpec ran on
      the Ruby VM and this left the Java world out in the cold. Running RSpec
      via JRuby was possible but JRuby was a fledgeling project and also came
      with its own baggage, not the least of which was that Enterprise
      organizations weren't ready to embrace Ruby or even JRuby.</para>

      <para>Enter groovy and easyb. Groovy runs natively on the JVM with
      nothing more than a jar file in the classpath. This is key to lowering
      the barriers of adoption by that Enterprise segment of the population.
      What Groovy also provides is a dynamic language with all the power and
      syntatic sugar opportunities for creating a rich DSL. With all the
      pieces now available, easyb was primed to step in and put them all in
      place.</para>
    </section>

    <section>
      <title>Goals</title>

      <itemizedlist>
        <listitem>
          <para>Easy</para>
        </listitem>

        <listitem>
          <para>Natual Language DSL for capturing Behaviors</para>
        </listitem>

        <listitem>
          <para>Bridge gap between Stakeholders and Development</para>
        </listitem>
      </itemizedlist>

      <para>Easyb accomplishes all of these goals in spades as you'll see
      throughout this document. Goal #1 has always been, and continues to be,
      that it must be easy. To do so, easyb provides out of the box a slew of
      great features and the easyb team has bundled along with (and built on
      top of them) a suite of products and plugins.</para>
    </section>
  </chapter>

  <chapter>
    <title>Intro to BDD</title>

    <para>Test Driven Development has proved itself useful for a number of
    reasons. Improving code quality up front, documenting the intentions of
    the code its testing (to a small extent), and even assure that bugs are
    not reintroduced during refactoring. It does not, however, work well to
    capture the requirements for which the application code is supposed to be
    implementing. What often happens is that a separate set of requirements
    are created and maintained. Even worse is that the interpretation of those
    requirements is most likely different between those that created them and
    those that are writing code to implement them. This can be directly linked
    to cost of a project because work has to be redone to make the code
    reflect what the requirements creators had in mind.</para>

    <para>Behavior Driven Development takes the approach that Stakeholders and
    Developers should be on the same page when it comes to interpretation of
    requirements. It is accomplished by changing the verbiage used when
    defining requirements. This is a key factor because Stakeholders are most
    often not technical, however, the developers that they employ to implement
    their requirements primarily know how to communicate in very technical
    terms. So a common pattern of capturing requirements was created. It is
    very specific about capturing exactly the context, events and outcomes
    that make up a requirement, or in BDD terms, a scenario. The scenario is
    captured in this form:</para>

    <simplelist>
      <member>given an initial context</member>

      <member>when an event occurs</member>

      <member>then ensure the outcome</member>
    </simplelist>

    <para>Writing scenarios in this fashion removes the ambiguity and allows
    both sides to focus on properly capturing and implementing the
    requirements knowing they are on the same page. </para>

    <para>Lets look at an example requirement and how it fits into the BDD
    model. The ubiquitous Bank Account example should do just fine. </para>

    <simplelist>
      <member>given an account with 100 dollars</member>

      <member>when account holder withdrawls 20 dollars</member>

      <member>then account should have 80 dollars left</member>
    </simplelist>
  </chapter>

  <chapter>
    <title>Usage</title>

    <para>Some stuff about running easyb</para>

    <section>
      <title>...Ways to run it</title>

      <para></para>
    </section>

    <section>
      <title>Reporting</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Syntax</title>

    <indexterm class="startofrange" id="ix.syntax">
      <primary>Syntax Specification</primary>
    </indexterm>

    <para>easyb contains a rich language for capturing behaviors as executable
    documentation.</para>

    <section>
      <title>Stories</title>

      <indexterm class="startofrange" id="ix.syntax.stories">
        <primary>Syntax Specification</primary>

        <secondary>Stories</secondary>
      </indexterm>

      <para>These entries are normally found within a Story file.</para>

      <section>
        <title>scenario</title>

        <indexterm>
          <primary>scenario</primary>
        </indexterm>

        <para>Illustrate a specific aspect of behavior of the
        application</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside story file. Multiple may be included in a single story
          file.</para>
        </formalpara>

        <programlisting>scenario "description here", {
  ...
}</programlisting>
      </section>

      <section>
        <title>given, andGiven</title>

        <indexterm>
          <primary>given</primary>
        </indexterm>

        <indexterm>
          <primary>andGiven</primary>

          <see>given</see>
        </indexterm>

        <para>Context specific to this scenario. Object and Data setup will
        often happen in a given.</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside scenario. Multiple may appear in each scenario. Also
          appears directly in a story file outside of a scenario (not
          recommended).</para>
        </formalpara>

        <programlisting>scenario "scenario description here", {
  given "given description here", {
    // given impl here
  }
 
  andGiven "andGiven description here", {
    // andGiven impl here
  }

  ...
}</programlisting>
      </section>

      <section>
        <title>when</title>

        <indexterm>
          <primary>when</primary>
        </indexterm>

        <para>An action to be taken.</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside scenario. Follows any givens. Multiple may appear in
          each scenario. Also appears directly in a story file outside of a
          scenario (not recommended).</para>
        </formalpara>

        <programlisting>scenario "scenario description here", {
  ...

  when "when description here", {
    // when impl here
  }

  ...
}</programlisting>
      </section>

      <section>
        <title>then, andThen</title>

        <indexterm>
          <primary>then</primary>
        </indexterm>

        <indexterm>
          <primary>andThen</primary>

          <see>then</see>
        </indexterm>

        <para>Validation of expected outcome.</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside scenario. Follows any whens. Multiple may appear in
          each scenario. Also appears directly in a story file outside of a
          scenario (not recommended).</para>
        </formalpara>

        <programlisting>scenario "scenario description here", {
  ...

  then "then description here", {
    // then impl here
  }

  andThen "andThen description here", {
    // andThen impl here
  }

  ...
}</programlisting>
      </section>

      <section>
        <title>narrative</title>

        <indexterm>
          <primary>narrative</primary>
        </indexterm>

        <para>Gives a bried description of what is to be delivered. Provides a
        container for other narrative components.</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside a story, preferably at the top. Only one can appear in
          each story.</para>
        </formalpara>

        <programlisting>narrative "narrative description here", {
  ...
}

scenario "scenario description here"  ...</programlisting>
      </section>

      <section>
        <title>as_a</title>

        <indexterm>
          <primary>as_a</primary>
        </indexterm>

        <para>An aspect that describes the person, or thing, that will benefit
        from the feature.</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside narrative, prior to i_want.</para>
        </formalpara>

        <programlisting>narrative "narrative description here", {
  as_a "role description here"
  ...
}</programlisting>
      </section>

      <section>
        <title>i_want</title>

        <indexterm>
          <primary>i_want</primary>
        </indexterm>

        <para>Describes something that the system should do or a feature in
        business terms and not in terms of technology</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside narrative, following as_a.</para>
        </formalpara>

        <programlisting>narrative "narrative description here", {
  ...
  i_want "feature description here"
  ...
}</programlisting>
      </section>

      <section>
        <title>so_that</title>

        <indexterm>
          <primary>so_that</primary>
        </indexterm>

        <para>Describes the business value accrued from this feature.</para>

        <formalpara>
          <title>Appears</title>

          <para>Inside narrative, following i_want.</para>
        </formalpara>

        <programlisting>narrative "narrative description here", {
  ...
  so_that "benefit description here"
}</programlisting>
      </section>

      <indexterm class="endofrange" startref="ix.syntax.stories" />
    </section>

    <section>
      <title>Specifications</title>

      <indexterm class="startofrange" id="ix.syntax.specifications">
        <primary>Syntax Specification</primary>

        <secondary>Specifications</secondary>
      </indexterm>

      <para>The entries below would normally be found exclusively in a
      Specification file.</para>

      <section>
        <title>it</title>

        <indexterm>
          <primary>it</primary>
        </indexterm>

        <para>Captures a specification. Usually described in terms of
        should.</para>

        <formalpara>
          <title>Appears</title>

          <para>At the root of a Specification file.</para>
        </formalpara>

        <programlisting>it "should have an it description here", {
  // it impl here
}</programlisting>
      </section>

      <indexterm class="endofrange" startref="ix.syntax.specifications" />
    </section>

    <section>
      <title>Common</title>

      <indexterm class="startofrange" id="ix.syntax.common">
        <primary>Syntax Specification</primary>

        <secondary>Common</secondary>
      </indexterm>

      <para>The following can be placed in both Story and Specification
      files.</para>

      <section>
        <title>and (syntax replacement)</title>

        <indexterm>
          <primary>and (syntax replacement)</primary>
        </indexterm>

        <para>Used as replacement syntax for story and specification
        contstructs. Carries the connotation that it is equivalent to whatever
        the previous story or specification construct was.</para>

        <formalpara>
          <title>Appears</title>

          <para>between, or in place of, story and specification constructs
          (given, then, etc)</para>
        </formalpara>

        <programlisting>...
given "a given description here", {
  // given impl here
}

and "equivalent to another given", {
  // another given impl here
}
...</programlisting>
      </section>

      <section>
        <title>and (assertion chain)</title>

        <indexterm>
          <primary>and (assertion chain)</primary>
        </indexterm>

        <para>Used to logically tie together assertion statements.</para>

        <formalpara>
          <title>Appears</title>

          <para>within a story or specification construct, placed between
          assertions to give more natural language readability</para>
        </formalpara>

        <programlisting>true.shouldBe true
and
false.shouldBe false</programlisting>
      </section>

      <section>
        <title>before</title>

        <indexterm>
          <primary>before</primary>
        </indexterm>

        <para>Actions to be taken before any Story or Scenario components are
        run. Usually used for boilerplate setup common to all scenarios or
        specifications in that file. Placement should be prior to any
        scenarios (in a story) or specifications.</para>

        <formalpara>
          <title>Appears</title>

          <para>At the top of a story or specification, prior to any other
          easyb components.</para>
        </formalpara>

        <programlisting>...
before "a before description here", {
  // before impl here
}
...</programlisting>
      </section>

      <section>
        <title>before_each</title>

        <indexterm>
          <primary>before_each</primary>
        </indexterm>

        <para>Actions to be taken before every Story or Scenario component is
        run. Usually used for boilerplate setup common to all scenarios or
        specifications in that file. Placement should be prior to any
        scenarios (in a story) or specifications.</para>

        <formalpara>
          <title>Appears</title>

          <para>At the top of a story or specification, prior to any other
          easyb components.</para>
        </formalpara>

        <programlisting>...
before_each "a before_each description here", {
  // before_each impl here
}
...</programlisting>
      </section>

      <section>
        <title>after</title>

        <indexterm>
          <primary>after</primary>
        </indexterm>

        <para>Actions to be taken after any Story or Scenario components are
        run. Usually used for boilerplate setup common to all scenarios or
        specifications in that file. Placement should be prior to any
        scenarios (in a story) or specifications.</para>

        <formalpara>
          <title>Appears</title>

          <para>At the top of a story or specification. Follows any before or
          before_each, prior to any other easyb components.</para>
        </formalpara>

        <programlisting>...
after "an after description here", {
  // after impl here
}
...</programlisting>
      </section>

      <section>
        <title>after_each</title>

        <indexterm>
          <primary>after_each</primary>
        </indexterm>

        <para>Actions to be taken after every Story or Scenario component is
        run. Placement should be prior to any scenarios (in a story) or
        specifications.</para>

        <formalpara>
          <title>Appears</title>

          <para>At the top of a story or specification. Follows any before or
          before_each, prior to any other easyb components.</para>
        </formalpara>

        <programlisting>...
after_each "an after_each description here", {
  // after_each impl here
}
...</programlisting>
      </section>

      <indexterm class="endofrange" startref="ix.syntax.common" />
    </section>

    <section>
      <title>Assertions</title>

      <para>The meat of the syntactic sugar easyb provides for making
      assertions very readable.</para>

      <section>
        <title>should</title>

        <para>All of the should assertions work from left to right. The object
        on the left having the attributes that will be validated by what is on
        the right.</para>

        <indexterm class="startofrange" id="ix.syntax.assertions.should">
          <primary>Syntax Specification</primary>

          <secondary>Should Assertions</secondary>
        </indexterm>

        <formalpara>
          <title>Appears</title>

          <para>Inside any of the story or scenario components, typically as
          part of an 'it' or a 'then'.</para>
        </formalpara>

        <section>
          <title>shouldBe</title>

          <indexterm>
            <primary>shouldBe</primary>
          </indexterm>

          <para>Equality of target checked against value passed in.</para>

          <programlisting>...
true.shouldBe true
...</programlisting>
        </section>

        <section>
          <title>shouldEqual</title>

          <indexterm>
            <primary>shouldEqual</primary>

            <seealso>shouldBe</seealso>
          </indexterm>

          <para>Synonym for shouldBe. Equality of target checked against value
          passed in.</para>

          <programlisting>...
true.shouldEqual true
...</programlisting>
        </section>

        <section>
          <title>shouldBeEqual</title>

          <indexterm>
            <primary>shouldBeEqual</primary>

            <seealso>shouldBe</seealso>
          </indexterm>

          <para>Synonym for shouldBe. Equality of target checked against value
          passed in.</para>

          <programlisting>...
true.shouldBeEqual true
...</programlisting>
        </section>

        <section>
          <title>shouldBeEqualTo</title>

          <indexterm>
            <primary>shouldBeEqualTo</primary>

            <seealso>shouldBe</seealso>
          </indexterm>

          <para>Synonym for shouldBe. Equality of target checked against value
          passed in.</para>

          <programlisting>...
true.shouldBeEqualTo true
...</programlisting>
        </section>

        <section>
          <title>shouldNotBe</title>

          <indexterm>
            <primary>shouldNotBe</primary>
          </indexterm>

          <para>Inequality of target checked against value passed in.</para>

          <programlisting>...
true.shouldNotBe false
...</programlisting>
        </section>

        <section>
          <title>shouldNotEqual</title>

          <indexterm>
            <primary>shouldNotEqual</primary>

            <seealso>shouldNotBe</seealso>
          </indexterm>

          <para>Synonym for shouldNotBe. Inequality of target checked against
          value passed in.</para>

          <programlisting>...
true.shouldNotEqual false
...</programlisting>
        </section>

        <section>
          <title>shouldNotBeEqual</title>

          <indexterm>
            <primary>shouldNotBeEqual</primary>

            <seealso>shouldNotBe</seealso>
          </indexterm>

          <para>Synonym for shouldNotBe. Inequality of target checked against
          value passed in.</para>

          <programlisting>...
true.shouldNotBeEqual false
...</programlisting>
        </section>

        <section>
          <title>shouldNotBeEqualTo</title>

          <indexterm>
            <primary>shouldNotBeEqualTo</primary>

            <seealso>shouldNotBe</seealso>
          </indexterm>

          <para>Synonym for shouldNotBe. Inequality of target object checked
          against value passed in.</para>

          <programlisting>...
true.shouldNotBeEqualTo false
...</programlisting>
        </section>

        <section>
          <title>shouldBeA</title>

          <indexterm>
            <primary>shouldBeA</primary>
          </indexterm>

          <para>Verifies the target's type matches that which is passed
          in.</para>

          <programlisting>...
"StringValue".shouldBeA(String)
...</programlisting>
        </section>

        <section>
          <title>shouldBeA</title>

          <indexterm>
            <primary>shouldBeA</primary>
          </indexterm>

          <para>Verifies the target's type matches that which is passed
          in.</para>

          <programlisting>...
"StringValue".shouldBeA String
...</programlisting>
        </section>

        <section>
          <title>shouldBeAn</title>

          <indexterm>
            <primary>shouldBeAn</primary>

            <seealso>shouldBeA</seealso>
          </indexterm>

          <para>Synonym for shouldBeA. Verifies the target's type matches that
          which is passed in.</para>

          <programlisting>...
1.shouldBeAn Integer
...</programlisting>
        </section>

        <section>
          <title>shouldNotBeA</title>

          <indexterm>
            <primary>shouldNotBeA</primary>
          </indexterm>

          <para>Verifies the target's type does not match that which is passed
          in.</para>

          <programlisting>...
1.shouldNotBeA String
...</programlisting>
        </section>

        <section>
          <title>shouldNotBeAn</title>

          <indexterm>
            <primary>shouldNotBeAn</primary>

            <seealso>shouldNotBeA</seealso>
          </indexterm>

          <para>Synonym for shouldNotBeA. Verifies the target's type does not
          match that which is passed in.</para>

          <programlisting>...
1.shouldBeAn Integer
...</programlisting>
        </section>

        <section>
          <title>shouldBeGreaterThan</title>

          <indexterm>
            <primary>shouldBeGreaterThan</primary>
          </indexterm>

          <para>Verifies the target is greater than the value passed in using
          groovy comparison.</para>

          <programlisting>...
2.shouldBeGreaterThan 1
...</programlisting>
        </section>

        <section>
          <title>shouldBeLessThan</title>

          <indexterm>
            <primary>shouldBeLessThan</primary>
          </indexterm>

          <para>Verifies the target is less than the value passed in using
          groovy comparison.</para>

          <programlisting>...
1.shouldBeLessThan 2
...</programlisting>
        </section>

        <section>
          <title>shouldHave</title>

          <indexterm>
            <primary>shouldHave</primary>
          </indexterm>

          <para>Verifies the target contains the value passed in. Collections
          and Strings are handled in the value positions. Collections, Strings
          and Object Fields are handled in the target position.</para>

          <programlisting>...
"test".shouldHave("est")

myMap = [value: "Andy", another: 34, 55: "test"]
myMap.shouldHave("Andy")
myMap.shouldHave(55: "test")
myMap.shouldHave([value: "Andy", 55: "test"])
...</programlisting>
        </section>

        <section>
          <title>shouldNotHave</title>

          <indexterm>
            <primary>shouldNotHave</primary>
          </indexterm>

          <para>Verifies the target contains the value passed in. Collections
          and Strings are handled in the value positions. Collections, Strings
          and Object Fields are handled in the target position.</para>

          <programlisting>...
myMap = [value: "Andy", another: 34, 55: "test"]
myMap.shouldNotHave("Mervin") // covers a value in a map
myMap.shouldNotHave([value: "Mervin", 55: "somethingnottest"]) // covers a map in a map where neither value is found
myMap.shouldNotHave([value: "Andy", 55: "somethingnottest"])  // covers a map in a map where at least one value is not found
myMap.shouldNotHave(55: "foobar") // covers map where key exists but value doesn't
...</programlisting>
        </section>

        <indexterm class="endofrange" startref="ix.syntax.assertions.should" />
      </section>

      <section>
        <title>ensure</title>

        <para>All of the ensure assertions validate the target (specified as
        the argument to ensure()) matches the assertion in the term or the
        argument to the right of the term.</para>

        <indexterm class="startofrange" id="ix.syntax.ensure">
          <primary>Syntax Specification</primary>

          <secondary>ensure</secondary>
        </indexterm>

        <formalpara>
          <title>Appears</title>

          <para>Ensure normally appears inside an 'it' or 'then. All of the
          assertion terms listed below will appear inside the block associated
          with the ensure itself.</para>
        </formalpara>

        <section>
          <title>isNull</title>

          <indexterm>
            <primary>isNull</primary>
          </indexterm>

          <para>Value of target must be null.</para>

          <programlisting>ensure(someNullTargetValue) {
 isNull
}</programlisting>
        </section>

        <section>
          <title>isNotNull</title>

          <indexterm>
            <primary>isNotNull</primary>
          </indexterm>

          <para>Value of target must not be null.</para>

          <programlisting>ensure(someNonNullTargetValue) {
 isNotNull
}</programlisting>
        </section>

        <section>
          <title>isA&lt;class type&gt;</title>

          <indexterm>
            <primary>isA</primary>
          </indexterm>

          <para>Value of target must be the same class as the &lt;class
          type&gt; at the end of the term.</para>

          <programlisting>ensure(aStringTarget) {
 isAString
}</programlisting>
        </section>

        <section>
          <title>isEqualTo(value)</title>

          <indexterm>
            <primary>isEqualTo(value)</primary>
          </indexterm>

          <para>Value of target must equal the value of the argument to
          isEqualTo.</para>

          <programlisting>ensure(true) {
 isEqualTo(true)
}</programlisting>
        </section>

        <section>
          <title>isEqualTo&lt;value&gt;</title>

          <indexterm>
            <primary>isEqualTo&lt;value&gt;</primary>
          </indexterm>

          <para>Value of target must equal the value at the end of the
          term.</para>

          <programlisting>ensure("Test") {
 isEqualToTest
}</programlisting>
        </section>

        <section>
          <title>isNotEqualTo(value)</title>

          <indexterm>
            <primary>isNotEqualTo(value)</primary>
          </indexterm>

          <para>Value of target must not equal the value of the argument to
          isNotEqualTo.</para>

          <programlisting>ensure(false) {
 isNotEqualTo(true)
}</programlisting>
        </section>

        <section>
          <title>isNotEqualTo&lt;value&gt;</title>

          <indexterm>
            <primary>isNotEqualTo&lt;value&gt;</primary>
          </indexterm>

          <para>Value of target must not equal the value at the end of the
          term.</para>

          <programlisting>ensure("Foo") {
 isNotEqualToBar
}</programlisting>
        </section>

        <section>
          <title>isTrue</title>

          <indexterm>
            <primary>isTrue</primary>
          </indexterm>

          <para>Value of target must be true.</para>

          <programlisting>ensure(true) {
 isTrue
}</programlisting>
        </section>

        <section>
          <title>isFalse</title>

          <indexterm>
            <primary>isFalse</primary>
          </indexterm>

          <para>Value of target must be false.</para>

          <programlisting>ensure(false) {
 isFalse
}</programlisting>
        </section>

        <section>
          <title>ensureThrows</title>

          <indexterm>
            <primary>ensureThrows</primary>
          </indexterm>

          <para>This is a special variant of the ensure clause. It is used to
          verify that a block of code must throw an exception of the type
          specified.</para>

          <programlisting>ensureThrows(RuntimeException.class) {
  String tst = null
  tst.toUpperCase()
}</programlisting>
        </section>

        <indexterm class="endofrange" startref="ix.syntax.ensure" />
      </section>

      <section>
        <title>common</title>

        <para>The remaining assertions are common to both stories and
        specifications. They can also be used standalone (inside of an ensure)
        as well as a magic method (similar to the should syntax).</para>

        <indexterm class="startofrange" id="ix.syntax.assertions.common">
          <primary>Syntax Specification</primary>

          <secondary>common assertions</secondary>
        </indexterm>

        <section>
          <title>has</title>

          <indexterm>
            <primary>has</primary>
          </indexterm>

          <para>Target's contents must consist of (at minimum) the contents of
          the argument to has.</para>

          <programlisting>ensure("Test") {
 has("es")
}</programlisting>

          <programlisting>...
 "Test".has("es") // Preferable to use shouldHave instead for readability
...</programlisting>
        </section>

        <section>
          <title>contains</title>

          <indexterm>
            <primary>contains</primary>
          </indexterm>

          <para>Target's contents must consist of (at minimum) the contents of
          the argument to contains.</para>

          <programlisting>ensure("Test") {
 contains("es")
}</programlisting>

          <programlisting>...
 "Test".contains("es") // Preferable to use shouldHave instead for readability
...</programlisting>
        </section>

        <section>
          <title>startsWith</title>

          <indexterm>
            <primary>startsWith</primary>
          </indexterm>

          <para>Target's contents must begin with the contents of the argument
          to startsWith.</para>

          <programlisting>ensure("Test") {
  startsWith("Te")
}</programlisting>

          <programlisting>... // Issue 110. shouldStartWith doesn't exist in the dsl yet
 "Test".shouldStartWith("Te") // Preferable to use shouldHave instead for readability
...</programlisting>
        </section>

        <section>
          <title>endsWith</title>

          <indexterm>
            <primary>endsWith</primary>
          </indexterm>

          <para>Target's contents must end with the contents of the argument
          to endsWith.</para>

          <programlisting>ensure("Test") {
  endsWith("st")
}</programlisting>

          <programlisting>... // Issue 111. shouldEndWith doesn't exist in the dsl yet
 "Test".shouldEndWith("st") // Preferable to use shouldHave instead for readability
...</programlisting>
        </section>

        <indexterm class="endofrange" startref="ix.syntax.assertions.common" />
      </section>
    </section>

    <indexterm class="endofrange" startref="ix.syntax" />
  </chapter>

  <chapter>
    <title>Appendix</title>

    <section>
      <title>Glossary<anchor id="glossary" /></title>

      <glosslist>
        <glossentry>
          <glossterm>BDD</glossterm>

          <glossdef>
            <para>See Behavior Driven Development</para>
          </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>Behavior Driven Development</glossterm>

          <glossdef>
            <para>Agile software development technique that encourages
            collaboration between developers, QA and non-technical or business
            participants in a software project. It was originally conceived in
            2003 by Dan North [1] as a response to Test Driven Development,
            and has evolved over the last few years. The focus of BDD is the
            language and interactions used in the process of software
            development. Behavior-driven developers use their native language
            in combination with the ubiquitous language of Domain Driven
            Design to describe the purpose and benefit of their code. This
            allows the developers to focus on why the code should be created,
            rather than the technical details, and minimizes translation
            between the technical language in which the code is written and
            the domain language spoken by the business, users, stakeholders,
            project management etc. (Courtesy:
            http://en.wikipedia.org/wiki/Behavior_driven_development)</para>
          </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>Story</glossterm>

          <glossdef>
            <para>Description of a requirement, which has an associated
            benefit and criteria for validation. Contains any of the following
            components: scenario, given, when then. It also may contain a
            narrative with the following components: narrative, as_a, i_want,
            so_that.</para>
          </glossdef>
        </glossentry>
      </glosslist>

      <para></para>
    </section>
  </chapter>

  <index></index>
</book>
